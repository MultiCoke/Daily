## 设计模式

### 1. 单例模式

+ 适用场景
  + 重量级的对象，不需要多个实例，如线程池，数据库连接池
  + 类图：

![image-20200929203211619](C:\Users\HY\Documents\Study\0.Java\0.JavaBase\0.Note\30.Java设计模式.assets\image-20200929203211619.png)

+ 实现

  1. 懒汉模式：延迟加载，只有在真正使用的时候，才开始实例化

     + 线程安全问题，使用synchronized进行加锁
     + 两次check，提高效率

     + 对私有的实例加上volatile关键字，严格底层指令的执行顺序

     + 实现

       ```java
       package com.upmerge.lazysingleton;
       
       /**
        * @author Upmerge
        * @package com.upmerge.lazysingleton
        * @date 2020/9/29 20:00
        */
       public class LazySingletonTest01 {
           public static void main(String[] args) {
               new Thread(() -> {
                   LazySingleton instance1 = LazySingleton.getInstance();
                   System.out.println(instance1);
               }).start();
       
               new Thread(() -> {
                   LazySingleton instance2 = LazySingleton.getInstance();
                   System.out.println(instance2);
               }).start();
           }
       }
       
       class LazySingleton{
           // volatile防止执行被编译器，cpu重排序
           private volatile static LazySingleton instance;
       
           // 私有化构造器，防止外部使用new
           private LazySingleton(){}
       
           public static LazySingleton getInstance(){
               if(instance == null){
                   synchronized (LazySingleton.class){
                       // 双重check
                       if(instance == null){
                           instance = new LazySingleton();
                       }
                   }
               }
       
               return instance;
           }
       }
       ```

       

  2. 饿汉模式

     + JVM类加载阶段完成初始化，保证唯一性和线程安全

     + 内加载过程

       ![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MTkzMDAyMjU4?x-oss-process=image/format,png)

     + 类的初始化先为静态变量分配内存，设置默认值，再执行静态成员变量的赋值语句

     + 实现

       ```java
       package com.upmerge.HungrySingleton;
       
       /**
        * @author Upmerge
        * @package com.upmerge.HungrySingleton
        * @date 2020/9/29 20:42
        */
       public class HungrySingletonTest01 {
           public static void main(String[] args) {
               new Thread(() -> {
                   HungrySingleton instance1 = HungrySingleton.getInstance();
                   System.out.println(instance1);
               }).start();
       
               new Thread(() -> {
                   HungrySingleton instance2 = HungrySingleton.getInstance();
                   System.out.println(instance2);
               }).start();
           }
       }
       
       class HungrySingleton{
           private static HungrySingleton instance = new HungrySingleton();
       
           private HungrySingleton() {}
       
           public static HungrySingleton getInstance(){
               return instance;
           }
       }
       ```

  3. 匿名内部类

     + 使用类的加载机制，保证线程安全

     + 懒加载机制，使用时触发类的初始化

     + 实现

       ```java
       package com.upmerge.InnerSingleton;
       
       /**
        * @author Upmerge
        * @package com.upmerge.InnerSingleton
        * @date 2020/9/29 21:09
        */
       public class InnerSingletonTest {
           public static void main(String[] args) {
               new Thread(() -> {
                   InnerSingleton instance1 = InnerSingleton.getInstance();
                   System.out.println(instance1);
               }).start();
       
               new Thread(() -> {
                   InnerSingleton instance2 = InnerSingleton.getInstance();
                   System.out.println(instance2);
               }).start();
           }
       }
       
       class InnerSingleton{
           private static class InnerSingletonHolder{
               private static InnerSingleton instance = new InnerSingleton();
           }
       
           private InnerSingleton(){}
       
           public static InnerSingleton getInstance(){
               return InnerSingletonHolder.instance;
           }
       }
       ```

  4. 攻击实例

     + 反射攻击，利用反射执行被攻击对象的私有化构造器得到两个不同的实例对象
     
       ```java
       package com.upmerge.InnerSingleton;
       
       import java.lang.reflect.Constructor;
       import java.lang.reflect.InvocationTargetException;
       
       /**
        * @author Upmerge
        * @package com.upmerge.InnerSingleton
        * @date 2020/9/29 21:09
        */
       public class InnerSingletonTest {
           public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
               Constructor<InnerSingleton> constructor = InnerSingleton.class.getDeclaredConstructor();
               constructor.setAccessible(true);
               InnerSingleton instance1 = constructor.newInstance();
               InnerSingleton instance2 = InnerSingleton.getInstance();
               System.out.println(instance1 == instance2);	// false
           }
       }
       
       class InnerSingleton{
           private static class InnerSingletonHolder{
               private static InnerSingleton instance = new InnerSingleton();
           }
       
           private InnerSingleton(){
               // 解决方法
               if(InnerSingletonHolder.instance != null){
                   throw new RuntimeException("Multi Instance");
               }
           }
       
           public static InnerSingleton getInstance(){
               return InnerSingletonHolder.instance;
           }
  }
       ```
     
     + 序列化攻击，利用对象反序列化生成新的实例方法进行攻击
     
       ```java
       package com.upmerge.lazysingleton;
       
       import java.io.*;
       
       /**
        * @author Upmerge
        * @package com.upmerge.lazysingleton
        * @date 2020/9/29 20:00
        */
       public class LazySingletonTest {
           public static void main(String[] args) throws IOException, ClassNotFoundException {
               LazySingleton instance1 = LazySingleton.getInstance();
       
               ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("text"));
               oos.writeObject(instance1);
       
               ObjectInputStream ois = new ObjectInputStream(new FileInputStream("text"));
               LazySingleton instance2 = ((LazySingleton) ois.readObject());
       
               System.out.println(instance1 == instance2);
           }
       }
       
       class LazySingleton implements Serializable {
           // volatile防止执行被编译器，cpu重排序
           private volatile static LazySingleton instance;
       
           // 私有化构造器，防止外部使用new
           private LazySingleton(){
               if(instance != null){
                   throw new RuntimeException("Multi instance");
               }
           }
       
           public static LazySingleton getInstance(){
               if(instance == null){
                   synchronized (LazySingleton.class){
                       // 双重check
                       if(instance == null){
                           instance = new LazySingleton();
                       }
                   }
               }
       
               return instance;
           }
       	
           // 实现此方法可使反序列化生成的对象为同一个对象
           private Object readResolve() throws ObjectStreamException {
               return instance;
           }
       }
       
       ```
     
  5. 枚举类
  
     + 天生支持线程安全
  
     + 支持反序列化
  
       ```java
       package com.upmerge.enumsingleton;
       
       /**
        * @author Upmerge
        * @package com.upmerge.enumsingleton
        * @date 2020/10/6 17:02
        */
       public class EnumSingletonTest {
           public static void main(String[] args) {
               EnumSingleton instance = EnumSingleton.getInstance();
               EnumSingleton instance1 = EnumSingleton.getInstance();
       
               System.out.println(instance == instance1);
           }
       }
       
       enum EnumSingleton{
           INSTANCE;
       
           public static EnumSingleton getInstance(){
               return INSTANCE;
           }
       }
       ```

### 2.工厂方法模式

1. 简单工厂模式

   + 简单工厂模式：又称静态工厂方法模式，它属于类创建型模式，在简单工厂模式中，可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。

   + 类图

     ![image-20201006200346664](C:\Users\HY\Documents\Study\0.Java\0.JavaBase\0.Note\30.Java设计模式.assets\image-20201006200346664.png)

   + 优点：工厂类含有必要的判断逻辑**，可以决定在什么时候创建哪一个产品类的实例，**客户端可以免除直接创建产品对象的责任，而仅仅"消费"产品。简单工厂模式通过这种做法实现了对责任的分割。**简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象**。通过它，外界可以从直接创建具体产品对象的尴尬局面中摆脱出来。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。   

   + 缺点：当产品有复杂的多层等级结构时，工厂类只有自己，以不变应万变，就是模式的缺点。因为工厂类集中了所有产品创建逻辑，**一旦增加产品或者删除产品，整个系统都要受到影响。系统扩展困难**，一旦添加新产品就不得不修改工厂逻辑，有可能造成工厂逻辑过于复杂,违背了"开放--封闭"原则(OCP).另外，**简单工厂模式通常使用静态工厂方法**，这使得无法由子类继承，**造成工厂角色无法形成基于继承的等级结构。**     

   + 应用：**工厂类负责创建的对象比较少，****客户只知道传入了工厂类的参数**，对于始何创建对象（逻辑）不关心。       

   + 实现：

     ```java
     package com.upmerge.simplefactory;
     
     /**
      * @author Upmerge
      * @package com.upmerge.simplefactory
      * @date 2020/10/6 19:58
      */
     public class SimpleFactoryTest {
         public static void main(String[] args) {
             Product a = ProductFactory.getProduct("A");
             a.print();
     
             Product b = ProductFactory.getProduct("B");
             b.print();
         }
     }
     
     // 产品父类
     abstract class Product{
         public abstract void print();
     }
     
     // 继承子类
     class ProductA extends Product{
     
         @Override
         public void print() {
             System.out.println("ProductA");
         }
     }
     
     class ProductB extends Product{
     
         @Override
         public void print() {
             System.out.println("ProductB");
         }
     }
     
     // 简单工厂类
     class ProductFactory{
         public static Product getProduct(String s){
             if(s.equals("A")){
                 return new ProductA();
             }else if(s.equals("B")){
                 return new ProductB();
             }else{
                 return null;
             }
         }
     }
     ```



2. 工厂方法模式

   + 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到其子类

   + 类图

     ![image-20201006201523055](C:\Users\HY\Documents\Study\0.Java\0.JavaBase\0.Note\30.Java设计模式.assets\image-20201006201523055.png)

   + 优点：**工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。**简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。**工厂方法模式完全满足OCP，即它有非常良好的扩展性。**

   + 缺点：假如某个**具体产品类**需要进行一定的修改，很可能需要修改对应的工厂类。**当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦**。比如说，每增加一个产品，相应的也要增加一个子工厂，会加大了额外的开发量。 

   + 应用：当一个类不知道它所必须创建对象的类或**一个类希望由子类来指定它所创建的对象时**，**当类将创建对象的职责委托给多个帮助子类中的某一个**，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候，可以使用工厂方法，**支持多扩展少修改的OCP原则。**         

   + 实现

     ```java
     package com.upmerge.factorymethod;
     
     /**
      * @author Upmerge
      * @package com.upmerge.factorymethod
      * @date 2020/10/6 20:20
      */
     public class FactoryMethodTest {
         public static void main(String[] args) {
             ProductAFactory productAFactory = new ProductAFactory();
             Product a = productAFactory.createProduct();
             a.print();
     
             ProductBFactory productBFactory = new ProductBFactory();
             Product b = productBFactory.createProduct();
             b.print();
         }
     }
     
     // 产品父类
     abstract class Product{
         public abstract void print();
     }
     
     // 继承子类
     class ProductA extends Product {
     
         @Override
         public void print() {
             System.out.println("ProductA");
         }
     }
     
     class ProductB extends Product {
     
         @Override
         public void print() {
             System.out.println("ProductB");
         }
     }
     
     // 工厂父类
     abstract class ProductFactory{
         public abstract Product createProduct();
     }
     
     // 产品工厂类
     class ProductAFactory extends ProductFactory{
     
         @Override
         public Product createProduct() {
             return new ProductA();
         }
     }
     
     class ProductBFactory extends ProductFactory{
         @Override
         public Product createProduct() {
             return new ProductB();
         }
     }
     ```

3. 抽象工厂模式

   + 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

   + 类图

     ![image-20201006203311287](C:\Users\HY\Documents\Study\0.Java\0.JavaBase\0.Note\30.Java设计模式.assets\image-20201006203311287.png)

   + 优点：抽象工厂模式主要在于**应对“新系列”的需求变化**。分离了具体的类，抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。它使得易于交换产品系列。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，**这是因为一个抽象工厂创建了一个完整的产品系列，**所以整个产品系列会立刻改变。**它有利于产品的一致性**。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。抽象工厂模式有助于这样的团队的分工，**降低了模块间的耦合性，提高了团队开发效率。**     

   + 缺点：抽象工厂模式在于难于应付新对象”的需求变动。难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。 

   + 应用：**一**个系统不应当依赖于**产品类实例**如何被**创建、组合和表达**的细节，这对于所有形态的工厂模式都是重要的。这个系统有多于一个的**产品族**，**而系统只消费其中某一产品族**。同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现

   + 实现

     ```java
     package com.upmerge.abstractfactory;
     
     /**
      * @author Upmerge
      * @package com.upmerge.abstractfactory
      * @date 2020/10/6 20:34
      */
     public class AbstractFactoryTest {
         public static void main(String[] args) {
             ProductFactory productFactory = new ProductFactory();
             Phone iphone = productFactory.createPhone("iphone");
             iphone.print();
     
             Mask n95 = productFactory.createMask("n95");
             n95.print();
         }
     }
     
     // 手机产品父类
     abstract class Phone {
         public abstract void print();
     }
     
     // 手机实现子类
     class IPhone extends Phone {
     
         @Override
         public void print() {
             System.out.println("IPhone");
         }
     }
     
     // 口罩产品父类
     abstract class Mask {
         public abstract void print();
     }
     
     // 口罩实现子类
     class N95 extends Mask {
     
         @Override
         public void print() {
             System.out.println("N95");
         }
     }
     
     // 工厂抽象类
     abstract class Factory {
         // 生产手机抽象方法
         public abstract Phone createPhone(String s);
     
         // 生产口罩抽象方法
         public abstract Mask createMask(String s);
     }
     
     // 工厂实现类
     class ProductFactory extends Factory {
     
         @Override
         public Phone createPhone(String s) {
             if (s.equals("iphone")) {
                 return new IPhone();
             } else {
                 return null;
             }
         }
     
         @Override
         public Mask createMask(String s) {
             if (s.equals("n95")) {
                 return new N95();
             } else {
                 return null;
             }
         }
     }
     ```

     